version: "3"

# Isolated Three-Instance Setup
# Based on docs/INSTANCE_ISOLATION_PLAN.md
#
# Docker Compose manifests located in:
#   - isolated/ws-go/docker-compose.yml
#   - isolated/backend/docker-compose.yml
#   - isolated/backend/prometheus.yml
#
# Architecture:
#   - odin-ws-go (e2-small): WebSocket server only
#   - odin-backend (e2-small): NATS, Prometheus, Grafana, Loki, Promtail, Publisher
#   - odin-test-runner (e2-micro): Load testing client (ephemeral)

vars:
  GCP_PROJECT_ID:
    sh: echo "${GCP_PROJECT_ID:-odin-ws-server}"
  GCP_ZONE:
    sh: echo "${GCP_ZONE:-us-central1-a}"

  # Instance names
  WS_GO_INSTANCE: odin-ws-go
  BACKEND_INSTANCE: odin-backend
  TEST_RUNNER_INSTANCE: odin-test-runner

  # Machine types
  WS_GO_MACHINE_TYPE: e2-standard-4
  BACKEND_MACHINE_TYPE: e2-small
  TEST_RUNNER_MACHINE_TYPE: e2-standard-4

  # Get instance IPs dynamically
  WS_GO_EXTERNAL_IP:
    sh: gcloud compute instances describe {{.WS_GO_INSTANCE}} --zone={{.GCP_ZONE}} --format='get(networkInterfaces[0].accessConfigs[0].natIP)' 2>/dev/null || echo "not-found"
  WS_GO_INTERNAL_IP:
    sh: gcloud compute instances describe {{.WS_GO_INSTANCE}} --zone={{.GCP_ZONE}} --format='get(networkInterfaces[0].networkIP)' 2>/dev/null || echo "not-found"
  BACKEND_EXTERNAL_IP:
    sh: gcloud compute instances describe {{.BACKEND_INSTANCE}} --zone={{.GCP_ZONE}} --format='get(networkInterfaces[0].accessConfigs[0].natIP)' 2>/dev/null || echo "not-found"
  BACKEND_INTERNAL_IP:
    sh: gcloud compute instances describe {{.BACKEND_INSTANCE}} --zone={{.GCP_ZONE}} --format='get(networkInterfaces[0].networkIP)' 2>/dev/null || echo "not-found"
  TEST_RUNNER_INTERNAL_IP:
    sh: gcloud compute instances describe {{.TEST_RUNNER_INSTANCE}} --zone={{.GCP_ZONE}} --format='get(networkInterfaces[0].networkIP)' 2>/dev/null || echo "not-found"

# ============================================================================
# SETUP & PREREQUISITES
# ============================================================================

tasks:
  setup:
    desc: Configure gcloud CLI and authenticate
    cmds:
      - echo "üîß Setting up GCP environment..."
      - gcloud --version
      - gcloud auth login
      - gcloud config set project {{.GCP_PROJECT_ID}}
      - gcloud config set compute/zone {{.GCP_ZONE}}
      - echo "‚úÖ GCP configuration complete"
      - echo "   Project ‚Üí {{.GCP_PROJECT_ID}}"
      - echo "   Zone ‚Üí {{.GCP_ZONE}}"

  firewall:
    desc: Create firewall rules for isolated setup
    cmds:
      - echo "üî• Creating firewall rules..."

      # WebSocket (ws-go external access)
      - |
        gcloud compute firewall-rules create allow-websocket-isolated \
          --network=default \
          --allow=tcp:3004 \
          --source-ranges=0.0.0.0/0 \
          --target-tags=ws-server \
          --description="Allow WebSocket connections to ws-go" \
          2>/dev/null || echo "‚ö†Ô∏è  Rule 'allow-websocket-isolated' exists"

      # Prometheus scraping (backend ‚Üí ws-go metrics)
      - |
        gcloud compute firewall-rules create allow-prometheus-scrape-isolated \
          --network=default \
          --allow=tcp:3004 \
          --source-tags=backend \
          --target-tags=ws-server \
          --description="Allow Prometheus to scrape ws-go metrics (port 3004)" \
          2>/dev/null || echo "‚ö†Ô∏è  Rule 'allow-prometheus-scrape-isolated' exists"

      # NATS client (ws-go ‚Üí backend NATS)
      - |
        gcloud compute firewall-rules create allow-nats-internal \
          --network=default \
          --allow=tcp:4222 \
          --source-tags=ws-server \
          --target-tags=backend \
          --description="Allow ws-go to connect to NATS" \
          2>/dev/null || echo "‚ö†Ô∏è  Rule 'allow-nats-internal' exists"

      # Grafana UI (external access)
      - |
        gcloud compute firewall-rules create allow-grafana-isolated \
          --network=default \
          --allow=tcp:3010 \
          --source-ranges=0.0.0.0/0 \
          --target-tags=backend \
          --description="Allow Grafana UI access" \
          2>/dev/null || echo "‚ö†Ô∏è  Rule 'allow-grafana-isolated' exists"

      # Publisher API (testing)
      - |
        gcloud compute firewall-rules create allow-publisher-isolated \
          --network=default \
          --allow=tcp:3003 \
          --source-ranges=0.0.0.0/0 \
          --target-tags=backend \
          --description="Allow Publisher API access" \
          2>/dev/null || echo "‚ö†Ô∏è  Rule 'allow-publisher-isolated' exists"

      # Loki log ingestion (ws-go Promtail ‚Üí backend Loki)
      - |
        gcloud compute firewall-rules create allow-loki-push-isolated \
          --network=default \
          --allow=tcp:3100 \
          --source-tags=ws-server \
          --target-tags=backend \
          --description="Allow ws-go Promtail to push logs to Loki" \
          2>/dev/null || echo "‚ö†Ô∏è  Rule 'allow-loki-push-isolated' exists"

      - gcloud compute firewall-rules list --filter="name~'isolated'"
      - echo "‚úÖ Firewall rules configured"

  # ============================================================================
  # INFRASTRUCTURE - CREATE INSTANCES
  # ============================================================================

  create:ws-go:
    desc: Create dedicated ws-go instance (e2-small)
    cmds:
      - echo "üñ•Ô∏è  Creating ws-go instance..."
      - |
        gcloud compute instances create {{.WS_GO_INSTANCE}} \
          --zone={{.GCP_ZONE}} \
          --machine-type={{.WS_GO_MACHINE_TYPE}} \
          --network=default \
          --subnet=default \
          --tags=ws-server \
          --boot-disk-size=10GB \
          --boot-disk-type=pd-standard \
          --image-family=ubuntu-2404-lts-amd64 \
          --image-project=ubuntu-os-cloud \
          --metadata=startup-script='#!/bin/bash
            set -e
            apt-get update
            apt-get install -y curl git

            # Install Docker
            curl -fsSL https://get.docker.com -o get-docker.sh
            sh get-docker.sh

            # Install Docker Compose
            curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
            chmod +x /usr/local/bin/docker-compose

            # Kernel tuning for high-scale connections
            # See docs/KERNEL_CONFIGURATION.md for details

            # Docker NAT connection tracking for 15K connections
            sysctl -w net.netfilter.nf_conntrack_max=262144

            # TCP listen queue for connection bursts
            sysctl -w net.ipv4.tcp_max_syn_backlog=16384
            sysctl -w net.core.somaxconn=16384

            # SYN cookie protection
            sysctl -w net.ipv4.tcp_syncookies=1

            # Make kernel settings permanent
            echo "net.netfilter.nf_conntrack_max = 262144" >> /etc/sysctl.conf
            echo "net.ipv4.tcp_max_syn_backlog = 16384" >> /etc/sysctl.conf
            echo "net.core.somaxconn = 16384" >> /etc/sysctl.conf
            echo "net.ipv4.tcp_syncookies = 1" >> /etc/sysctl.conf

            # File descriptor limits for 15K connections
            echo "* soft nofile 200000" >> /etc/security/limits.conf
            echo "* hard nofile 200000" >> /etc/security/limits.conf
            echo "root soft nofile 200000" >> /etc/security/limits.conf
            echo "root hard nofile 200000" >> /etc/security/limits.conf
            echo "deploy soft nofile 200000" >> /etc/security/limits.conf
            echo "deploy hard nofile 200000" >> /etc/security/limits.conf

            # Create deploy user and add to docker group
            useradd -m -s /bin/bash deploy
            usermod -aG docker deploy

            echo "‚úÖ ws-go instance ready"
          '
      - echo "‚è≥ Waiting for instance to be ready..."
      - sleep 30
      - task: info:ws-go
      - echo "‚úÖ ws-go instance created"

  create:backend:
    desc: Create backend instance (e2-small) for NATS, monitoring, etc.
    cmds:
      - echo "üñ•Ô∏è  Creating backend instance..."
      - |
        gcloud compute instances create {{.BACKEND_INSTANCE}} \
          --zone={{.GCP_ZONE}} \
          --machine-type={{.BACKEND_MACHINE_TYPE}} \
          --network=default \
          --subnet=default \
          --tags=backend \
          --boot-disk-size=20GB \
          --boot-disk-type=pd-standard \
          --image-family=ubuntu-2404-lts-amd64 \
          --image-project=ubuntu-os-cloud \
          --metadata=startup-script='#!/bin/bash
            set -e
            apt-get update
            apt-get install -y curl git

            # Install Docker
            curl -fsSL https://get.docker.com -o get-docker.sh
            sh get-docker.sh

            # Install Docker Compose
            curl -L "https://github.com/docker/compose/releases/latest/download/docker-compose-$(uname -s)-$(uname -m)" -o /usr/local/bin/docker-compose
            chmod +x /usr/local/bin/docker-compose

            # Create deploy user and add to docker group
            useradd -m -s /bin/bash deploy
            usermod -aG docker deploy

            echo "‚úÖ backend instance ready"
          '
      - echo "‚è≥ Waiting for instance to be ready..."
      - sleep 30
      - task: info:backend
      - echo "‚úÖ backend instance created"

  create:test-runner:
    desc: Create test runner instance (supports both Node.js and Go test runners)
    cmds:
      - echo "üñ•Ô∏è  Creating test runner instance (e2-standard-4)..."
      - echo "   Supports both Node.js (event loop demo) and Go (7K capacity testing)"
      - |
        gcloud compute instances create {{.TEST_RUNNER_INSTANCE}} \
          --zone={{.GCP_ZONE}} \
          --machine-type={{.TEST_RUNNER_MACHINE_TYPE}} \
          --network=default \
          --subnet=default \
          --tags=test-runner \
          --boot-disk-size=10GB \
          --boot-disk-type=pd-standard \
          --image-family=ubuntu-2404-lts-amd64 \
          --image-project=ubuntu-os-cloud \
          --metadata=startup-script='#!/bin/bash
            set -e
            apt-get update
            apt-get install -y curl

            # Install Docker
            curl -fsSL https://get.docker.com -o get-docker.sh
            sh get-docker.sh

            # Kernel tuning for high-scale client connections
            # See docs/KERNEL_CONFIGURATION.md for details

            # Ephemeral port range for 15K outbound connections
            sysctl -w net.ipv4.ip_local_port_range="10000 65000"

            # TIME_WAIT socket reuse for rapid connection cycling
            sysctl -w net.ipv4.tcp_tw_reuse=1

            # TIME_WAIT timeout reduction for faster cleanup
            sysctl -w net.ipv4.tcp_fin_timeout=15

            # Connection tracking table size
            sysctl -w net.netfilter.nf_conntrack_max=200000

            # Make kernel settings permanent
            echo "net.ipv4.ip_local_port_range = 10000 65000" >> /etc/sysctl.conf
            echo "net.ipv4.tcp_tw_reuse = 1" >> /etc/sysctl.conf
            echo "net.ipv4.tcp_fin_timeout = 15" >> /etc/sysctl.conf
            echo "net.netfilter.nf_conntrack_max = 200000" >> /etc/sysctl.conf

            # File descriptor limits for 15K connections
            echo "* soft nofile 200000" >> /etc/security/limits.conf
            echo "* hard nofile 200000" >> /etc/security/limits.conf
            echo "root soft nofile 200000" >> /etc/security/limits.conf
            echo "root hard nofile 200000" >> /etc/security/limits.conf
            echo "deploy soft nofile 200000" >> /etc/security/limits.conf
            echo "deploy hard nofile 200000" >> /etc/security/limits.conf

            # Create deploy user and add to docker group
            useradd -m -s /bin/bash deploy
            usermod -aG docker deploy

            echo "‚úÖ test-runner instance ready (supports Node.js and Go test runners)"
          '
      - echo "‚è≥ Waiting for instance to be ready..."
      - sleep 30
      - echo "‚úÖ test-runner instance created"

  create:test-runner-go:
    desc: Create test runner instance for Go-based load testing (alias to create:test-runner)
    cmds:
      - task: create:test-runner

  create:all:
    desc: Create all instances (backend + ws-go + test-runner)
    cmds:
      - task: create:backend
      - task: create:ws-go
      - task: create:test-runner
      - echo ""
      - echo "üéâ All instances created!"
      - task: info:all

  # ============================================================================
  # DEPLOYMENT - COPY FILES & START SERVICES
  # ============================================================================

  deploy:ws-go:
    desc: Deploy ws-go service to dedicated instance
    cmds:
      - echo "üì¶ Deploying ws-go..."

      # Copy source code and manifest to deploy user's home
      - echo "üì§ Copying source files and manifest..."
      - gcloud compute ssh {{.WS_GO_INSTANCE}} --zone={{.GCP_ZONE}} --command='rm -rf /tmp/ws_poc_deploy && mkdir -p /tmp/ws_poc_deploy'
      - gcloud compute scp --recurse {{.USER_WORKING_DIR}}/src {{.WS_GO_INSTANCE}}:/tmp/ws_poc_deploy/ --zone={{.GCP_ZONE}}
      - gcloud compute scp {{.USER_WORKING_DIR}}/isolated/ws-go/docker-compose.yml {{.WS_GO_INSTANCE}}:/tmp/ws_poc_deploy/docker-compose.template.yml --zone={{.GCP_ZONE}}
      - gcloud compute scp {{.USER_WORKING_DIR}}/isolated/ws-go/promtail-config.yml {{.WS_GO_INSTANCE}}:/tmp/ws_poc_deploy/promtail-config.template.yml --zone={{.GCP_ZONE}}
      - gcloud compute scp {{.USER_WORKING_DIR}}/isolated/ws-go/.env.production {{.WS_GO_INSTANCE}}:/tmp/ws_poc_deploy/.env.production --zone={{.GCP_ZONE}}
      - gcloud compute ssh {{.WS_GO_INSTANCE}} --zone={{.GCP_ZONE}} --command='sudo rm -rf /home/deploy/ws_poc && sudo mkdir -p /home/deploy/ws_poc && sudo sh -c "mv /tmp/ws_poc_deploy/* /tmp/ws_poc_deploy/.[!.]* /home/deploy/ws_poc/ 2>/dev/null || true" && sudo chown -R deploy:deploy /home/deploy/ws_poc'

      # Substitute variables and deploy
      - echo "üìù Substituting variables (BACKEND_INTERNAL_IP={{.BACKEND_INTERNAL_IP}})..."
      - |
        gcloud compute ssh {{.WS_GO_INSTANCE}} --zone={{.GCP_ZONE}} --command="sudo bash -c 'cd /home/deploy/ws_poc && export BACKEND_INTERNAL_IP={{.BACKEND_INTERNAL_IP}} && envsubst < docker-compose.template.yml > docker-compose.yml && envsubst < promtail-config.template.yml > promtail-config.yml && envsubst < .env.production > .env.production.final && mv .env.production.final .env.production'"

      # Build and start
      - echo "üöÄ Building and starting ws-go..."
      - gcloud compute ssh {{.WS_GO_INSTANCE}} --zone={{.GCP_ZONE}} --command="sudo docker compose -f /home/deploy/ws_poc/docker-compose.yml build"
      - gcloud compute ssh {{.WS_GO_INSTANCE}} --zone={{.GCP_ZONE}} --command="sudo docker compose -f /home/deploy/ws_poc/docker-compose.yml up -d"

      # Wait and check
      - echo "‚è≥ Waiting for ws-go to start..."
      - sleep 10
      - task: health:ws-go
      - echo "‚úÖ ws-go deployed"

  deploy:backend:
    desc: Deploy backend services (NATS, monitoring, publisher)
    cmds:
      - echo "üì¶ Deploying backend services..."

      # Copy manifests and configs to deploy user's home
      - echo "üì§ Copying manifests and configuration files..."
      - gcloud compute ssh {{.BACKEND_INSTANCE}} --zone={{.GCP_ZONE}} --command='rm -rf /tmp/ws_poc_deploy && mkdir -p /tmp/ws_poc_deploy'
      - gcloud compute scp {{.USER_WORKING_DIR}}/isolated/backend/docker-compose.yml {{.BACKEND_INSTANCE}}:/tmp/ws_poc_deploy/docker-compose.yml --zone={{.GCP_ZONE}}
      - gcloud compute scp {{.USER_WORKING_DIR}}/isolated/backend/prometheus.yml {{.BACKEND_INSTANCE}}:/tmp/ws_poc_deploy/prometheus.template.yml --zone={{.GCP_ZONE}}
      - gcloud compute scp {{.USER_WORKING_DIR}}/loki-config.yml {{.BACKEND_INSTANCE}}:/tmp/ws_poc_deploy/loki-config.yml --zone={{.GCP_ZONE}}
      - gcloud compute scp {{.USER_WORKING_DIR}}/promtail-config.yml {{.BACKEND_INSTANCE}}:/tmp/ws_poc_deploy/promtail-config.yml --zone={{.GCP_ZONE}}
      - gcloud compute scp --recurse {{.USER_WORKING_DIR}}/grafana {{.BACKEND_INSTANCE}}:/tmp/ws_poc_deploy/ --zone={{.GCP_ZONE}}
      - gcloud compute scp --recurse {{.USER_WORKING_DIR}}/publisher {{.BACKEND_INSTANCE}}:/tmp/ws_poc_deploy/ --zone={{.GCP_ZONE}}
      - gcloud compute ssh {{.BACKEND_INSTANCE}} --zone={{.GCP_ZONE}} --command='sudo rm -rf /home/deploy/ws_poc && sudo mkdir -p /home/deploy/ws_poc && sudo mv /tmp/ws_poc_deploy/* /home/deploy/ws_poc/ && sudo chown -R deploy:deploy /home/deploy/ws_poc'

      # Substitute Prometheus config variables
      - echo "üìù Substituting Prometheus variables (WS_GO_INTERNAL_IP={{.WS_GO_INTERNAL_IP}})..."
      - |
        gcloud compute ssh {{.BACKEND_INSTANCE}} --zone={{.GCP_ZONE}} --command="sudo bash -c 'cd /home/deploy/ws_poc && export WS_GO_INTERNAL_IP={{.WS_GO_INTERNAL_IP}} && envsubst < prometheus.template.yml > prometheus.yml && cat prometheus.yml'"

      # Build and start
      - echo "üöÄ Building and starting backend services..."
      - gcloud compute ssh {{.BACKEND_INSTANCE}} --zone={{.GCP_ZONE}} --command="sudo docker compose -f /home/deploy/ws_poc/docker-compose.yml build"
      - gcloud compute ssh {{.BACKEND_INSTANCE}} --zone={{.GCP_ZONE}} --command="sudo docker compose -f /home/deploy/ws_poc/docker-compose.yml up -d"

      # Wait and check
      - echo "‚è≥ Waiting for services to start..."
      - sleep 15
      - task: health:backend
      - echo "‚úÖ Backend services deployed"

  deploy:all:
    desc: Deploy all instances (backend + ws-go + Go test-runner)
    cmds:
      - task: deploy:backend
      - task: deploy:ws-go
      - task: deploy:test-runner-go
      - echo ""
      - echo "üéâ Full deployment complete!"
      - echo ""
      - task: info:all

  deploy:test-runner:
    desc: Deploy Node.js test runner (demonstrates event loop bottleneck)
    cmds:
      - echo "üì¶ Deploying Node.js test runner to test-runner instance..."
      - |
        echo "‚ö†Ô∏è  NOTE: Node.js test runner will hit event loop bottleneck at ~3K connections"

      # Prepare directories
      - gcloud compute ssh {{.TEST_RUNNER_INSTANCE}} --zone={{.GCP_ZONE}} --command='rm -rf /tmp/test_runner_deploy && mkdir -p /tmp/test_runner_deploy'

      # Copy test runner files to temp
      - gcloud compute scp {{.USER_WORKING_DIR}}/isolated/test-runner/Dockerfile {{.TEST_RUNNER_INSTANCE}}:/tmp/test_runner_deploy/ --zone={{.GCP_ZONE}}
      - gcloud compute scp {{.USER_WORKING_DIR}}/scripts/sustained-load-test.cjs {{.TEST_RUNNER_INSTANCE}}:/tmp/test_runner_deploy/ --zone={{.GCP_ZONE}}
      - gcloud compute scp {{.USER_WORKING_DIR}}/scripts/test-connection-rate.cjs {{.TEST_RUNNER_INSTANCE}}:/tmp/test_runner_deploy/ --zone={{.GCP_ZONE}}
      - gcloud compute scp {{.USER_WORKING_DIR}}/scripts/test-message-throughput.cjs {{.TEST_RUNNER_INSTANCE}}:/tmp/test_runner_deploy/ --zone={{.GCP_ZONE}}

      # Move to deploy user's home and build
      - gcloud compute ssh {{.TEST_RUNNER_INSTANCE}} --zone={{.GCP_ZONE}} --command='sudo rm -rf /home/deploy/test-runner && sudo mkdir -p /home/deploy/test-runner && sudo mv /tmp/test_runner_deploy/* /home/deploy/test-runner/ && sudo chown -R deploy:deploy /home/deploy/test-runner'
      - gcloud compute ssh {{.TEST_RUNNER_INSTANCE}} --zone={{.GCP_ZONE}} --command='sudo docker build -t ws-test-runner /home/deploy/test-runner'
      - echo "‚úÖ Node.js test runner deployed and built"

  deploy:test-runner-go:
    desc: Deploy Go test runner (solves event loop bottleneck - RECOMMENDED)
    cmds:
      - echo "üì¶ Deploying Go test runner to test-runner instance..."
      - echo "‚ú® Go test runner uses goroutines - no event loop bottleneck!"

      # Prepare directories
      - gcloud compute ssh {{.TEST_RUNNER_INSTANCE}} --zone={{.GCP_ZONE}} --command='rm -rf /tmp/test_runner_go_deploy && mkdir -p /tmp/test_runner_go_deploy'

      # Copy Go test runner files
      - echo "üì§ Copying Go test runner files..."
      - gcloud compute scp {{.USER_WORKING_DIR}}/isolated/test-runner-go/Dockerfile {{.TEST_RUNNER_INSTANCE}}:/tmp/test_runner_go_deploy/ --zone={{.GCP_ZONE}}
      - gcloud compute scp {{.USER_WORKING_DIR}}/scripts/sustained-load-test.go {{.TEST_RUNNER_INSTANCE}}:/tmp/test_runner_go_deploy/ --zone={{.GCP_ZONE}}
      - gcloud compute scp {{.USER_WORKING_DIR}}/scripts/go.mod {{.TEST_RUNNER_INSTANCE}}:/tmp/test_runner_go_deploy/ --zone={{.GCP_ZONE}}
      - gcloud compute scp {{.USER_WORKING_DIR}}/scripts/go.sum {{.TEST_RUNNER_INSTANCE}}:/tmp/test_runner_go_deploy/ --zone={{.GCP_ZONE}} 2>/dev/null || echo "‚ö†Ô∏è  No go.sum file (will be generated during build)"

      # Move to deploy user's home and build
      - gcloud compute ssh {{.TEST_RUNNER_INSTANCE}} --zone={{.GCP_ZONE}} --command='sudo rm -rf /home/deploy/test-runner-go && sudo mkdir -p /home/deploy/test-runner-go && sudo mv /tmp/test_runner_go_deploy/* /home/deploy/test-runner-go/ && sudo chown -R deploy:deploy /home/deploy/test-runner-go'
      - echo "üî® Building Go test runner image (goroutine-based, no event loop bottleneck)..."
      - gcloud compute ssh {{.TEST_RUNNER_INSTANCE}} --zone={{.GCP_ZONE}} --command='sudo docker build -t ws-test-runner-go /home/deploy/test-runner-go'
      - echo "‚úÖ Go test runner deployed and built"

  # ============================================================================
  # HEALTH & STATUS
  # ============================================================================

  health:ws-go:
    desc: Check ws-go health
    cmds:
      - echo "üè• Checking ws-go health..."
      - |
        curl -s http://{{.WS_GO_EXTERNAL_IP}}:3004/health | jq '.' || echo "‚ùå Health check failed"

  health:backend:
    desc: Check backend services health
    cmds:
      - echo "üè• Checking backend services..."
      - echo ""
      - echo "üìä NATS status:"
      - gcloud compute ssh {{.BACKEND_INSTANCE}} --zone={{.GCP_ZONE}} --command="curl -s http://localhost:8222/varz | jq -r '.server_name, .version'" && echo "‚úÖ NATS running" || echo "‚ùå NATS check failed"
      - echo ""
      - echo "üìà Prometheus status:"
      - gcloud compute ssh {{.BACKEND_INSTANCE}} --zone={{.GCP_ZONE}} --command="curl -s http://localhost:9091/-/ready" && echo "‚úÖ Prometheus ready" || echo "‚ùå Prometheus not ready"
      - echo ""
      - echo "üìâ Grafana status:"
      - curl -s http://{{.BACKEND_EXTERNAL_IP}}:3010/api/health | jq '.' || echo "‚ùå Grafana check failed"

  health:test-runner:
    desc: Check test-runner instance status
    cmds:
      - echo "üè• Checking test-runner instance..."
      - gcloud compute ssh {{.TEST_RUNNER_INSTANCE}} --zone={{.GCP_ZONE}} --command="sudo docker --version" && echo "‚úÖ Test-runner ready" || echo "‚ùå Test-runner not accessible"

  health:all:
    desc: Check health of all services
    cmds:
      - task: health:backend
      - echo ""
      - task: health:ws-go
      - echo ""
      - task: health:test-runner

  info:ws-go:
    desc: Show ws-go instance information
    cmds:
      - echo "üìç ws-go Instance Info:"
      - echo "   Name ‚Üí {{.WS_GO_INSTANCE}}"
      - echo "   Zone ‚Üí {{.GCP_ZONE}}"
      - echo "   External IP ‚Üí {{.WS_GO_EXTERNAL_IP}}"
      - echo "   Internal IP ‚Üí {{.WS_GO_INTERNAL_IP}}"
      - echo "   WebSocket ‚Üí ws://{{.WS_GO_EXTERNAL_IP}}:3004/ws"
      - echo "   Health ‚Üí http://{{.WS_GO_EXTERNAL_IP}}:3004/health"
      - echo "   Metrics ‚Üí http://{{.WS_GO_EXTERNAL_IP}}:3004/metrics"

  info:backend:
    desc: Show backend instance information
    cmds:
      - echo "üìç Backend Instance Info:"
      - echo "   Name ‚Üí {{.BACKEND_INSTANCE}}"
      - echo "   Zone ‚Üí {{.GCP_ZONE}}"
      - echo "   External IP ‚Üí {{.BACKEND_EXTERNAL_IP}}"
      - echo "   Internal IP ‚Üí {{.BACKEND_INTERNAL_IP}}"
      - echo "   Grafana ‚Üí http://{{.BACKEND_EXTERNAL_IP}}:3010"
      - echo "   Prometheus ‚Üí http://{{.BACKEND_EXTERNAL_IP}}:9091"
      - echo "   Publisher ‚Üí http://{{.BACKEND_EXTERNAL_IP}}:3003"

  info:test-runner:
    desc: Show test-runner instance information
    cmds:
      - echo "üìç Test Runner Instance Info:"
      - echo "   Name ‚Üí {{.TEST_RUNNER_INSTANCE}}"
      - echo "   Zone ‚Üí {{.GCP_ZONE}}"
      - echo "   Internal IP ‚Üí {{.TEST_RUNNER_INTERNAL_IP}}"
      - echo "   Machine Type ‚Üí {{.TEST_RUNNER_MACHINE_TYPE}}"
      - echo "   Resources ‚Üí 4 vCPU (sustained), 16GB RAM"

  info:all:
    desc: Show information for all instances
    cmds:
      - task: info:backend
      - echo ""
      - task: info:ws-go
      - echo ""
      - task: info:test-runner
      - echo ""
      - echo "üîó Quick Access:"
      - echo "   Grafana ‚Üí http://{{.BACKEND_EXTERNAL_IP}}:3010 (admin/admin)"
      - echo "   Test WS ‚Üí wscat -c ws://{{.WS_GO_EXTERNAL_IP}}:3004/ws"

  list:
    desc: List all running VMs in the project
    cmds:
      - echo "üñ•Ô∏è  Listing all compute instances..."
      - gcloud compute instances list

  ip:
    desc: Show key URLs (quick access)
    cmds:
      - echo "üîó WebSocket Server:"
      - echo "ws://{{.WS_GO_EXTERNAL_IP}}:3004/ws"
      - echo ""
      - echo "üè• Health Check:"
      - echo "http://{{.WS_GO_EXTERNAL_IP}}:3004/health"
      - echo ""
      - echo "üìä Grafana:"
      - echo "http://{{.BACKEND_EXTERNAL_IP}}:3010"
      - echo "(admin/admin)"
      - echo ""
      - echo "üì° Publisher:"
      - echo "http://{{.BACKEND_EXTERNAL_IP}}:3003"

  # ============================================================================
  # SSH & LOGS
  # ============================================================================

  ssh:ws-go:
    desc: SSH into ws-go instance
    cmds:
      - gcloud compute ssh {{.WS_GO_INSTANCE}} --zone={{.GCP_ZONE}}

  ssh:backend:
    desc: SSH into backend instance
    cmds:
      - gcloud compute ssh {{.BACKEND_INSTANCE}} --zone={{.GCP_ZONE}}

  logs:ws-go:
    desc: Show ws-go logs
    cmds:
      - gcloud compute ssh {{.WS_GO_INSTANCE}} --zone={{.GCP_ZONE}} --command='sudo docker compose -f /home/deploy/ws_poc/docker-compose.yml logs -f --tail=100'

  logs:backend:
    desc: Show backend services logs
    cmds:
      - gcloud compute ssh {{.BACKEND_INSTANCE}} --zone={{.GCP_ZONE}} --command='sudo docker compose -f /home/deploy/ws_poc/docker-compose.yml logs -f --tail=100'

  logs:nats:
    desc: Show NATS logs
    cmds:
      - gcloud compute ssh {{.BACKEND_INSTANCE}} --zone={{.GCP_ZONE}} --command='sudo docker logs -f odin-nats'

  logs:prometheus:
    desc: Show Prometheus logs
    cmds:
      - gcloud compute ssh {{.BACKEND_INSTANCE}} --zone={{.GCP_ZONE}} --command='sudo docker logs -f odin-prometheus'

  # ============================================================================
  # PUBLISHER CONTROL
  # ============================================================================

  publisher:health:
    desc: Check publisher health
    cmds:
      - curl -s http://{{.BACKEND_EXTERNAL_IP}}:3003/health | jq '.'

  publisher:stats:
    desc: Show publisher statistics
    cmds:
      - curl -s http://{{.BACKEND_EXTERNAL_IP}}:3003/stats | jq '.'

  publisher:start:
    desc: Start publishing messages (25 msg/sec - production rate)
    cmds:
      - echo "‚ñ∂Ô∏è  Starting publisher..."
      - |
        curl -X POST http://{{.BACKEND_EXTERNAL_IP}}:3003/control \
          -H "Content-Type: application/json" \
          -d '{"action": "start", "messagesPerSecond": 25, "connections": 7000}' | jq '.'
      - echo ""
      - echo "‚úÖ Publisher started (25 messages/sec - production rate)"

  publisher:stop:
    desc: Stop publishing messages
    cmds:
      - echo "‚èπÔ∏è  Stopping publisher..."
      - |
        curl -X POST http://{{.BACKEND_EXTERNAL_IP}}:3003/control \
          -H "Content-Type: application/json" \
          -d '{"action": "stop"}' | jq '.'

  publisher:start:high:
    desc: Start publishing at high rate (50 msg/sec)
    cmds:
      - echo "‚ñ∂Ô∏è  Starting publisher at high rate..."
      - |
        curl -X POST http://{{.BACKEND_EXTERNAL_IP}}:3003/control \
          -H "Content-Type: application/json" \
          -d '{"action": "start", "messagesPerSecond": 50, "connections": 7000}' | jq '.'
      - echo ""
      - echo "‚úÖ Publisher started (50 messages/sec - high rate)"

  # ============================================================================
  # TESTING
  # ============================================================================

  test:connection:
    desc: Test WebSocket connection
    cmds:
      - echo "üß™ Testing WebSocket connection..."
      - wscat -c ws://{{.WS_GO_EXTERNAL_IP}}:3004/ws

  test:light:
    desc: Light load test (1,000 connections, 60s)
    cmds:
      - echo "üß™ Running light load test..."
      - WS_URL=ws://{{.WS_GO_EXTERNAL_IP}}:3004/ws HEALTH_URL=http://{{.WS_GO_EXTERNAL_IP}}:3004/health WS_MAX_CONNECTIONS=7000 TARGET_CONNECTIONS=1000 DURATION=60 node scripts/sustained-load-test.cjs

  test:medium:
    desc: Medium load test (5,000 connections, 300s)
    cmds:
      - echo "üß™ Running medium load test..."
      - WS_URL=ws://{{.WS_GO_EXTERNAL_IP}}:3004/ws HEALTH_URL=http://{{.WS_GO_EXTERNAL_IP}}:3004/health WS_MAX_CONNECTIONS=7000 TARGET_CONNECTIONS=5000 DURATION=300 node scripts/sustained-load-test.cjs

  test:capacity:
    desc: Production capacity test (7,000 connections - target, 600s)
    cmds:
      - echo "üß™ Running production capacity test..."
      - WS_URL=ws://{{.WS_GO_EXTERNAL_IP}}:3004/ws HEALTH_URL=http://{{.WS_GO_EXTERNAL_IP}}:3004/health WS_MAX_CONNECTIONS=7000 TARGET_CONNECTIONS=7000 DURATION=600 node scripts/sustained-load-test.cjs

  test:overload:
    desc: Overload test (10,000 connections, should reject 3K gracefully)
    cmds:
      - echo "üß™ Running overload test (expect rejections above 7K)..."
      - WS_URL=ws://{{.WS_GO_EXTERNAL_IP}}:3004/ws HEALTH_URL=http://{{.WS_GO_EXTERNAL_IP}}:3004/health WS_MAX_CONNECTIONS=7000 TARGET_CONNECTIONS=10000 DURATION=300 node scripts/sustained-load-test.cjs

  # Remote tests (run in Docker on test-runner instance using Go - no event loop bottleneck)
  test:remote:light:
    desc: Light load test (1,000 connections, 60s) - runs remotely with Go test runner
    cmds:
      - echo "üß™ Running light load test remotely (Go)..."
      - |
        gcloud compute ssh {{.TEST_RUNNER_INSTANCE}} --zone={{.GCP_ZONE}} --command='sudo docker run --rm \
          --ulimit nofile=200000:200000 \
          --sysctl net.ipv4.ip_local_port_range="10000 65000" \
          --sysctl net.ipv4.tcp_tw_reuse=1 \
          --sysctl net.ipv4.tcp_fin_timeout=15 \
          -e WS_URL=ws://{{.WS_GO_INTERNAL_IP}}:3004/ws \
          -e HEALTH_URL=http://{{.WS_GO_INTERNAL_IP}}:3004/health \
          -e WS_MAX_CONNECTIONS=7000 \
          -e TARGET_CONNECTIONS=1000 \
          -e DURATION=60 \
          ws-test-runner-go'

  test:remote:medium:
    desc: Medium load test (5,000 connections, 300s) - runs remotely with Go test runner
    cmds:
      - echo "üß™ Running medium load test remotely (Go)..."
      - |
        gcloud compute ssh {{.TEST_RUNNER_INSTANCE}} --zone={{.GCP_ZONE}} --command='sudo docker run --rm \
          --ulimit nofile=200000:200000 \
          --sysctl net.ipv4.ip_local_port_range="10000 65000" \
          --sysctl net.ipv4.tcp_tw_reuse=1 \
          --sysctl net.ipv4.tcp_fin_timeout=15 \
          -e WS_URL=ws://{{.WS_GO_INTERNAL_IP}}:3004/ws \
          -e HEALTH_URL=http://{{.WS_GO_INTERNAL_IP}}:3004/health \
          -e WS_MAX_CONNECTIONS=7000 \
          -e TARGET_CONNECTIONS=5000 \
          -e DURATION=300 \
          ws-test-runner-go'

  test:remote:capacity:
    desc: Production capacity test (15,000 connections - target, 3600s) - runs remotely with Go test runner
    cmds:
      - echo "üß™ Running production capacity test remotely (Go)..."
      - |
        gcloud compute ssh {{.TEST_RUNNER_INSTANCE}} --zone={{.GCP_ZONE}} --command='sudo docker run --rm \
          --ulimit nofile=200000:200000 \
          --sysctl net.ipv4.ip_local_port_range="10000 65000" \
          --sysctl net.ipv4.tcp_tw_reuse=1 \
          --sysctl net.ipv4.tcp_fin_timeout=15 \
          -e WS_URL=ws://{{.WS_GO_INTERNAL_IP}}:3004/ws \
          -e HEALTH_URL=http://{{.WS_GO_INTERNAL_IP}}:3004/health \
          -e WS_MAX_CONNECTIONS=15000 \
          -e TARGET_CONNECTIONS=15000 \
          -e DURATION=3600 \
          ws-test-runner-go'

  test:remote:overload:
    desc: Overload test (10,000 connections - should reject excess, 300s) - runs remotely with Go test runner
    cmds:
      - echo "üß™ Running overload test remotely (Go) - expect rejections above 7K..."
      - |
        gcloud compute ssh {{.TEST_RUNNER_INSTANCE}} --zone={{.GCP_ZONE}} --command='sudo docker run --rm \
          --ulimit nofile=200000:200000 \
          --sysctl net.ipv4.ip_local_port_range="10000 65000" \
          --sysctl net.ipv4.tcp_tw_reuse=1 \
          --sysctl net.ipv4.tcp_fin_timeout=15 \
          -e WS_URL=ws://{{.WS_GO_INTERNAL_IP}}:3004/ws \
          -e HEALTH_URL=http://{{.WS_GO_INTERNAL_IP}}:3004/health \
          -e WS_MAX_CONNECTIONS=7000 \
          -e TARGET_CONNECTIONS=10000 \
          -e DURATION=300 \
          ws-test-runner-go'

  # ============================================================================
  # SPLIT TESTING STRATEGY - Isolate connection capacity from message throughput
  # ============================================================================

  test:throughput:500:
    desc: MESSAGE THROUGHPUT - 500 connections with full message load (5 min)
    cmds:
      - echo "üìä Running message throughput test (500 connections)..."
      - WS_URL=ws://{{.WS_GO_EXTERNAL_IP}}:3004/ws TARGET_CONNECTIONS=500 DURATION=300 node scripts/test-message-throughput.cjs

  test:throughput:1000:
    desc: MESSAGE THROUGHPUT - 1000 connections with full message load (5 min)
    cmds:
      - echo "üìä Running message throughput test (1000 connections)..."
      - WS_URL=ws://{{.WS_GO_EXTERNAL_IP}}:3004/ws TARGET_CONNECTIONS=1000 DURATION=300 node scripts/test-message-throughput.cjs

  test:capacity:5k:
    desc: CONNECTION CAPACITY - 5000 connections without messages (5 min)
    cmds:
      - echo "üîå Running connection capacity test (5000 connections, no messages)..."
      - WS_URL=ws://{{.WS_GO_EXTERNAL_IP}}:3004/ws TARGET_CONNECTIONS=5000 DURATION=300 node scripts/test-connection-rate.cjs

  test:capacity:10k:
    desc: CONNECTION CAPACITY - 10000 connections without messages (5 min)
    cmds:
      - echo "üîå Running connection capacity test (10000 connections, no messages)..."
      - WS_URL=ws://{{.WS_GO_EXTERNAL_IP}}:3004/ws TARGET_CONNECTIONS=10000 DURATION=300 node scripts/test-connection-rate.cjs

  # ============================================================================
  # REMOTE SPLIT TESTING - Run tests from test-runner instance (eliminates local client bottlenecks)
  # ============================================================================

  test:remote:throughput:500:
    desc: REMOTE MESSAGE THROUGHPUT - 500 connections with full message load (5 min)
    cmds:
      - echo "üìä Running remote message throughput test (500 connections)..."
      - |
        gcloud compute ssh {{.TEST_RUNNER_INSTANCE}} --zone={{.GCP_ZONE}} --command='sudo docker run --rm \
          -e WS_URL=ws://{{.WS_GO_INTERNAL_IP}}:3004/ws \
          -e TARGET_CONNECTIONS=500 \
          -e DURATION=300 \
          ws-test-runner node test-message-throughput.cjs'

  test:remote:throughput:1000:
    desc: REMOTE MESSAGE THROUGHPUT - 1000 connections with full message load (5 min)
    cmds:
      - echo "üìä Running remote message throughput test (1000 connections)..."
      - |
        gcloud compute ssh {{.TEST_RUNNER_INSTANCE}} --zone={{.GCP_ZONE}} --command='sudo docker run --rm \
          -e WS_URL=ws://{{.WS_GO_INTERNAL_IP}}:3004/ws \
          -e TARGET_CONNECTIONS=1000 \
          -e DURATION=300 \
          ws-test-runner node test-message-throughput.cjs'

  test:remote:capacity:5k:
    desc: REMOTE CONNECTION CAPACITY - 5000 connections without messages (5 min)
    cmds:
      - echo "üîå Running remote connection capacity test (5000 connections, no messages)..."
      - |
        gcloud compute ssh {{.TEST_RUNNER_INSTANCE}} --zone={{.GCP_ZONE}} --command='sudo docker run --rm \
          --ulimit nofile=200000:200000 \
          --sysctl net.ipv4.ip_local_port_range="10000 65000" \
          --sysctl net.ipv4.tcp_tw_reuse=1 \
          --sysctl net.ipv4.tcp_fin_timeout=15 \
          -e WS_URL=ws://{{.WS_GO_INTERNAL_IP}}:3004/ws \
          -e TARGET_CONNECTIONS=5000 \
          -e DURATION=300 \
          ws-test-runner node test-connection-rate.cjs'

  test:remote:capacity:10k:
    desc: REMOTE CONNECTION CAPACITY - 10000 connections without messages (5 min)
    cmds:
      - echo "üîå Running remote connection capacity test (10000 connections, no messages)..."
      - |
        gcloud compute ssh {{.TEST_RUNNER_INSTANCE}} --zone={{.GCP_ZONE}} --command='sudo docker run --rm \
          --ulimit nofile=200000:200000 \
          --sysctl net.ipv4.ip_local_port_range="10000 65000" \
          --sysctl net.ipv4.tcp_tw_reuse=1 \
          --sysctl net.ipv4.tcp_fin_timeout=15 \
          -e WS_URL=ws://{{.WS_GO_INTERNAL_IP}}:3004/ws \
          -e TARGET_CONNECTIONS=10000 \
          -e DURATION=300 \
          ws-test-runner node test-connection-rate.cjs'

  test:remote:capacity:7k:
    desc: REMOTE CONNECTION CAPACITY - 7000 connections production target (10 min)
    cmds:
      - echo "üîå Running remote connection capacity test (7000 connections - production target)..."
      - |
        gcloud compute ssh {{.TEST_RUNNER_INSTANCE}} --zone={{.GCP_ZONE}} --command='sudo docker run --rm \
          --ulimit nofile=200000:200000 \
          --sysctl net.ipv4.ip_local_port_range="10000 65000" \
          --sysctl net.ipv4.tcp_tw_reuse=1 \
          --sysctl net.ipv4.tcp_fin_timeout=15 \
          -e WS_URL=ws://{{.WS_GO_INTERNAL_IP}}:3004/ws \
          -e TARGET_CONNECTIONS=7000 \
          -e DURATION=600 \
          ws-test-runner node test-connection-rate.cjs'

  test:validate:100:
    desc: CONNECTION HEALTH VALIDATION - 100 connections with bidirectional health checks (5 min)
    cmds:
      - echo "üîç Running 100-connection health validation test..."
      - echo "   - Bidirectional message flow (client ‚Üî server)"
      - echo "   - Heartbeat verification (both directions)"
      - echo "   - TCP state validation every 5 seconds"
      - echo "   - Phantom detection (reported vs TCP)"
      - echo ""
      - cd scripts && go run connection-health-validator.go

  test:validate:1k:
    desc: "CONNECTION HEALTH VALIDATION - 1000 connections with phantom detection (10 min)"
    cmds:
      - echo "üîç Running 1K-connection health validation test..."
      - echo "   - Scale test 1000 concurrent connections"
      - echo "   - Ramp rate 100 connections/sec (10s ramp)"
      - echo "   - TCP state validation every 10 seconds"
      - echo "   - Phantom threshold 20 connections (2%)"
      - echo "   - Duration 10 minutes"
      - echo ""
      - cd scripts && go run connection-health-validator-1k.go

  # ============================================================================
  # RESTART & UPDATE
  # ============================================================================

  restart:ws-go:
    desc: Restart ws-go service
    cmds:
      - echo "üîÑ Restarting ws-go..."
      - gcloud compute ssh {{.WS_GO_INSTANCE}} --zone={{.GCP_ZONE}} --command="sudo docker compose -f /home/deploy/ws_poc/docker-compose.yml restart"
      - sleep 5
      - task: health:ws-go

  restart:backend:
    desc: Restart backend services
    cmds:
      - echo "üîÑ Restarting backend services..."
      - gcloud compute ssh {{.BACKEND_INSTANCE}} --zone={{.GCP_ZONE}} --command="sudo docker compose -f /home/deploy/ws_poc/docker-compose.yml restart"
      - sleep 10
      - task: health:backend

  restart:test-runner:
    desc: Restart test-runner (no-op - no persistent services)
    cmds:
      - echo "‚ÑπÔ∏è  Test-runner has no persistent services to restart"

  restart:all:
    desc: Restart all services
    cmds:
      - task: restart:backend
      - task: restart:ws-go
      - task: restart:test-runner
      - echo "‚úÖ All services restarted"

  restart:clean:
    desc: "Restart everything with clean slate (stops tests, restarts all services, clears phantoms)"
    cmds:
      - echo "üßπ CLEAN RESTART - Stopping all tests and restarting all services"
      - echo ""
      - echo "1Ô∏è‚É£  Stopping any running tests on test-runner..."
      - gcloud compute ssh {{.TEST_RUNNER_INSTANCE}} --zone={{.GCP_ZONE}} --command="sudo pkill -9 -f 'sustained-load-test|stress-test|validator' || echo 'No tests running'"
      - echo ""
      - echo "2Ô∏è‚É£  Restarting backend services (NATS, Prometheus, Grafana, Loki)..."
      - gcloud compute ssh {{.BACKEND_INSTANCE}} --zone={{.GCP_ZONE}} --command="sudo docker compose -f /home/deploy/ws_poc/docker-compose.yml restart"
      - sleep 5
      - echo ""
      - echo "3Ô∏è‚É£  Stopping publisher..."
      - task: publisher:stop
      - echo ""
      - echo "4Ô∏è‚É£  Restarting ws-go (clears all connections)..."
      - gcloud compute ssh {{.WS_GO_INSTANCE}} --zone={{.GCP_ZONE}} --command="sudo docker compose -f /home/deploy/ws_poc/docker-compose.yml restart"
      - sleep 10
      - echo ""
      - echo "5Ô∏è‚É£  Verifying clean slate..."
      - task: health:ws-go
      - echo ""
      - echo "6Ô∏è‚É£  Starting publisher..."
      - task: publisher:start
      - echo ""
      - echo "‚úÖ CLEAN RESTART COMPLETE"
      - echo ""
      - echo "üìä Current State:"
      - curl -s http://{{.WS_GO_EXTERNAL_IP}}:3004/health | jq '.checks.capacity'
      - echo ""
      - echo "üöÄ Ready for testing! All phantoms cleared."

  update:ws-go:
    desc: Update ws-go code and restart
    cmds:
      - echo "üì¶ Updating ws-go..."
      - gcloud compute scp --recurse {{.USER_WORKING_DIR}}/src {{.WS_GO_INSTANCE}}:/tmp/ --zone={{.GCP_ZONE}}
      - gcloud compute ssh {{.WS_GO_INSTANCE}} --zone={{.GCP_ZONE}} --command="sudo rm -rf /home/deploy/ws_poc/src && sudo mv /tmp/src /home/deploy/ws_poc/ && sudo chown -R deploy:deploy /home/deploy/ws_poc/src"
      - gcloud compute ssh {{.WS_GO_INSTANCE}} --zone={{.GCP_ZONE}} --command="sudo docker compose -f /home/deploy/ws_poc/docker-compose.yml build && sudo docker compose -f /home/deploy/ws_poc/docker-compose.yml up -d"
      - sleep 5
      - task: health:ws-go

  update:config:ws-go:
    desc: Update ws-go configuration (rebuild required)
    cmds:
      - echo "üìù Updating ws-go configuration..."
      - task: deploy:ws-go

  # ============================================================================
  # CLEANUP
  # ============================================================================

  stop:ws-go:
    desc: Stop ws-go service (keep instance running)
    cmds:
      - echo "‚èπÔ∏è  Stopping ws-go..."
      - gcloud compute ssh {{.WS_GO_INSTANCE}} --zone={{.GCP_ZONE}} --command="sudo docker compose -f /home/deploy/ws_poc/docker-compose.yml down"

  stop:backend:
    desc: Stop backend services (keep instance running)
    cmds:
      - echo "‚èπÔ∏è  Stopping backend services..."
      - gcloud compute ssh {{.BACKEND_INSTANCE}} --zone={{.GCP_ZONE}} --command="sudo docker compose -f /home/deploy/ws_poc/docker-compose.yml down"

  stop:test-runner:
    desc: Stop test-runner (no-op - no persistent services)
    cmds:
      - echo "‚ÑπÔ∏è  Test-runner has no persistent services to stop"

  stop:all:
    desc: Stop all services (keep instances running)
    cmds:
      - task: stop:ws-go
      - task: stop:backend
      - task: stop:test-runner
      - echo "‚úÖ All services stopped"

  delete:ws-go:
    desc: Delete ws-go instance
    cmds:
      - echo "üóëÔ∏è  Deleting ws-go instance..."
      - gcloud compute instances delete {{.WS_GO_INSTANCE}} --zone={{.GCP_ZONE}} --quiet || echo "‚ö†Ô∏è  Instance {{.WS_GO_INSTANCE}} not found or already deleted"

  delete:backend:
    desc: Delete backend instance
    cmds:
      - echo "üóëÔ∏è  Deleting backend instance..."
      - gcloud compute instances delete {{.BACKEND_INSTANCE}} --zone={{.GCP_ZONE}} --quiet || echo "‚ö†Ô∏è  Instance {{.BACKEND_INSTANCE}} not found or already deleted"

  delete:test-runner:
    desc: Delete test-runner instance
    cmds:
      - echo "üóëÔ∏è  Deleting test-runner instance..."
      - gcloud compute instances delete {{.TEST_RUNNER_INSTANCE}} --zone={{.GCP_ZONE}} --quiet || echo "‚ö†Ô∏è  Instance {{.TEST_RUNNER_INSTANCE}} not found or already deleted"

  delete:all:
    desc: Delete all instances
    cmds:
      - task: delete:ws-go
      - task: delete:backend
      - task: delete:test-runner
      - echo "‚úÖ All instances deleted"

  cleanup:firewall:
    desc: Delete firewall rules
    cmds:
      - echo "üóëÔ∏è  Cleaning up firewall rules..."
      - gcloud compute firewall-rules delete allow-websocket-isolated --quiet || true
      - gcloud compute firewall-rules delete allow-prometheus-scrape-isolated --quiet || true
      - gcloud compute firewall-rules delete allow-nats-internal --quiet || true
      - gcloud compute firewall-rules delete allow-loki-push-isolated --quiet || true
      - gcloud compute firewall-rules delete allow-grafana-isolated --quiet || true
      - gcloud compute firewall-rules delete allow-publisher-isolated --quiet || true
      - echo "‚úÖ Firewall rules cleaned up"

  cleanup:all:
    desc: Delete everything (instances + firewall rules)
    cmds:
      - task: delete:all
      - task: cleanup:firewall
      - echo "üéâ Complete cleanup done"
